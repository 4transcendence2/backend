@	PROTOCOL:	HTTP
@	PORT		:	80


----------------------------------------------------------


@	METHOD:	POST
@	URI		:	/auth/login
@ DESC	: 1차 로그인 요청

@ 요청시
@ Body data - json
{
  "username": string,	(필수)
  "password": string	(필수)
}


@ 반환값 (성공시)
@ StatusCode 201
{
  "status": "approved",
  "access_token": {tooken value} (2차 로그인 핸드폰 인증 번호 요청시 필요한 토큰. 무분별한 인증 요청 방지를 위함)
}


@ 반환값 (실패시)
@ StatusCode 401
{
  "statusCode": 401,
  "message": "Unauthorized"
}


----------------------------------------------------------


@	METHOD: GET
@	URI		:	/auth/get/otp/login
@ DESC	:	2차 로그인 핸드폰 인증 번호 요청


@ 요청시
@ Header data
Authorization: Bearer {token value} (1차 로그인 요청 성공시 반환 받은 token value, 띄어쓰기까지 정확하게 보내야 함.)


@ 토큰이 없는경우
@ statusCode 401, Unauthorized



----------------------------------------------------------


@ METHOD:	POST
@	URI		:	/auth/check/otp/login
@	DESC	:	2차 로그인 핸드폰 인증 번호 확인

@요청시
@ Body data - json
{
  "otp": string
}


@ 반환값 (성공시)
@ StatusCode 200
{
  "status": "approved",
  "access_token": {tooken value} (소켓 연결할 때 같이 전달해줘야 연결이 됩니다. 이후 모든 http 요청에도 사용해야합니다.)
}


@ 반환값 (실패시) 인증번호 요청 없이 바로 check 요청한 경우
@ StatusCode 404
{
  "status": "error"
  "detail": "Invalid Check Request"
}

@ 반환값 (실패시) 인즌벙호는 요청했지만 인증번호가 잘못 된 경우
@ StatusCode 401
{
  "status": "pending"
  "detail": "Invalid Token"
}


----------------------------------------------------------


@ METHOD:	POST
@	URI		:	/auth/get/otp/signup
@	DESC	:	회원가입 핸드폰 인증 번호 요청

@	요청시
@ Body data - json
{
  "phonenumber": string
}


@ 반환값 (프로퍼티에 문제가 있는경우)
{
	"statusCode": 400,
	"message": [
		"phonenumber should not be empty",
		"phonenumber must be a string"
	],
	"error": "Bad Request"
}


@ 반환값 ( 성공시 )
@ StatusCode 201


----------------------------------------------------------


@	METHOD:	POST
@	URI		:	/auth/check/otp/signup
@	DESC	:	회원가입 핸드폰 인증 번호 확인

@	요청시
@	Body data - json
{
  "phonenumber": string
  "otp": string
}

@ 반환값 (성공시)
@ StatusCode 200
{
  "status": "approved",
  "access_token": {tooken value} (/user/create 요청시 함께 넣어줘야 할 토큰)
}


@ 반환값 (실패시) 인증번호 요청 없이 바로 check 요청한 경우
@ StatusCode 404
{
  "status": "error"
  "detail": "Invalid Check Request"
}

@ 반환값 (실패시) 인즌벙호는 요청했지만 인증번호가 잘못 된 경우
@ StatusCode 401
{
  "status": "pending"
  "detail": "Invalid Token"
}

----------------------------------------------------------


@	METHOD:	POST
@	URI		:	/user/create
@	DESC	:	유저 생성 요청

@	요청시
@	Body data - json
{
  "username": string,	(아이디)
  "password": string,	(비밀번호)
  "nickname":	string, (닉네임)
  "phonenumber": string, (폰번호)
}

@	반환값 (성공시)
{
  "status":	"approved",
  "detail": "User is created"
}

@	반환값 (실패시, username 중복, nickname 중복, 토큰이 없는 경우, 요청시 프로퍼티가 잘못된 경우)
{
  "status": "error",
  "detail": {상황에 따른 에러 내용}
}


----------------------------------------------------------


@	METHOD:	GET
@	URI		:	/user/profile
@	DESC	:	요청을 한 유저의 모든 프로필 정보

@ 반환값 (성공시)
{
  // 아직 user 테이블 요소가 미정.
  // 현재는 해당 유저의 모든 정보가 반환됩니다.
  // 다른 유저 데이터 요청 API는 구현중
  // 게임 기록 데이터는, 추후 게임 서버 구현할 때 추가할 예정입니다.
}

@	반환값 (실패시, 토큰이 없는경우)
{
  "statusCode": 401,
  "detail":	"Unauthorized"
}


----------------------------------------------------------


@ METHOD:	POST
@	URI		:	/chat/create
@	DESC	:	채팅방 만들기 요청

@	요청시
@	Body data - json
{
  "status": string(public, private, protected 셋 중 하나여야 합니다.)
  "title": string,
  "password": string (protected인 경우만)
}

@ 반환값 (성공시)
{
  "status":	"approved",
  "detail":	"Chat room is created"
}


@	반환값 (실패시, 프로퍼티 조건 미충족, 토큰 미 첨부시)
{
  "status":	"error",
  "detail":	{에러내용}
}


----------------------------------------------------------












@	PROTOCOL:	WS
@	PORT		:	80
@	CAUTION	:	2 FA 인증 후 받은 토큰을 소켓 연결 할 때 꼭 함께 첨부해주세요.
const socket = io('ws://localhost', {
  extraHeaders: {
    Authorization: 'Bearer ' + token,
  }
})



----------------------------------------------------------


@ 채팅방 입장 이벤트

socket.emit('joinChatRoom', {
  "room_id": number,
  "password": string (protected 채팅방인 경우)
})

socket.on('joinChatRoomResult', data)
data: {
  "status": "error" || "warning" || "approved" ( error는 개발자 에게 알림, warning은 유저에게 알림)
  "detail": string
}

"status"가 "warning"인 경우, "detail"의 내용을 그대로 유저에게 알려주면 됩니다.


----------------------------------------------------------


@ 채팅방 퇴장 이벤트 (뒤로 가기가 아니라, 완전히 나가기)

socket.emit('exitChatRoom', {
  "room_id": number,
})


socket.on('exitChatRoomResult', data)
data: {
  "status": "error" || "approved" ( error는 개발자에게 알림)
  "detail": string
}


----------------------------------------------------------


@ 채팅 이벤트

socket.emit('chat', {
  "room_id": number,
  "content": string,
})

// 채팅 이벤트를 발생시켰을 때 결과를 반환받을 이벤트
socket.on('chatResult', data)
data: {
  "status": "error" || "warning" || "approved" ( error는 개발자 에게 알림, warning은 유저에게 알림)
  "detail": string
}

// 채팅방에 채팅이 발생했을 때 이벤트
socket.on('chat', data)
data: {
  "status": "plain" || "notice" (plain은 일반 채팅, notice는 입장, 퇴장 알림 등등)
  "from": string,
  "content": string,
}

"status"가 "warning"인 경우, "detail"의 내용을 그대로 유저에게 알려주면 됩니다.


----------------------------------------------------------


@ 퇴장 이벤트

socket.emit('kick', {
  "room_id": number,
  "username": string (퇴장 시킬 유저네임)
})


socket.on('kickResult', data)
data: {
  "status": "error" || "warning" || "approved" ( error는 개발자 에게 알림, warning은 유저에게 알림)
  "detail": string
}

"status"가 "warning"인 경우, "detail"의 내용을 그대로 유저에게 알려주면 됩니다.

// 구현 중.
// 추방 당했을 때, 이벤트
socket.on('kick', data)


----------------------------------------------------------


@ ban 이벤트

socket.emit('ban', {
  "room_id": number,
  "username": string (밴 시킬 유저네임)
})

socket.on('banResult', data)
data: {
  "status": "error" || "warning" || "approved" ( error는 개발자 에게 알림, warning은 유저에게 알림)
  "detail": string
}

"status"가 "warning"인 경우, "detail"의 내용을 그대로 유저에게 알려주면 됩니다.

// 구현 중.
// ban 당했을 때, 이벤트
socket.on('ban', data)


----------------------------------------------------------


@ unban 이벤트

socket.emit('unban', {
  "room_id": number,
  "username": string (언밴 시킬 유저네임)
})

socket.on('unbanResult', data)
data: {
  "status": "error" || "warning" || "approved" ( error는 개발자 에게 알림, warning은 유저에게 알림)
  "detail": string
}

"status"가 "warning"인 경우, "detail"의 내용을 그대로 유저에게 알려주면 됩니다.


----------------------------------------------------------


@ mute 이벤트

socket.emit('mute, {
  "room_id": number,
  "username": string (mute 시킬 유저네임)
})

socket.on('muteResult', data)
data: {
  "status": "error" || "warning" || "approved" ( error는 개발자 에게 알림, warning은 유저에게 알림)
  "detail": string
}

"status"가 "warning"인 경우, "detail"의 내용을 그대로 유저에게 알려주면 됩니다.


// 구현중
// mute 당했을 때, 이벤트
socket.on('mute', data)


----------------------------------------------------------


// 차단 기능 구현중


----------------------------------------------------------


@ 채팅방 목록 업데이트 이벤트

socket.on('updateChatRoomList', data)
data: {
	status: string,
	title: string,
	room_id: number,
} []


----------------------------------------------------------


@ 본인 채팅방 목록 업데이트 이벤트

socket.on('updateMyChatRoomList', data)
data: {
	title: string,
	room_id: number,
} []


----------------------------------------------------------


@ 친구 업데이트

socket.on('updateFriend', data)
data: {
	username: string,
	status: string,
} []


----------------------------------------------------------


@ 게임방 목록 업데이트
// 구현중


----------------------------------------------------------


@ 게임방 상태 업데이트
// 구현중


----------------------------------------------------------






----------------------------------------------------------
----------------------------------------------------------
----------------------------------------------------------
----------------------------------------------------------
----------------------------------------------------------
----------------------------------------------------------
